
/*  @Tramx   */

#include <opencv2/core/core.hpp>
#include "opencv2/opencv.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"

#include <iostream>
#include "IANH.h"
#include "NLIH.h"

#include "HyperDenoise.h"
#include "ImageNeighborKernel.h"
#include "DistanceKernel.h"


using namespace std;
typedef Hyper::IANH<Hyper::ImageNeighborKernel::NeighborSmall, Hyper::PixelDistanceKernel::AbsDistance1D> IANH;
typedef Hyper::NLIH<Hyper::ImageNeighborKernel::NeighborSmall, Hyper::PixelDistanceKernel::AbsDistance1D> NLIH;

IplImage* putNoise(IplImage* _image, int _thresW, int _thresB){
    cv::Mat img = cv::Mat(_image);
    cv::Mat saltpepper_noise = cv::Mat::zeros(img.rows, img.cols,CV_8U);
    randu(saltpepper_noise,0,255);

    cv::Mat black = saltpepper_noise < _thresB;
    cv::Mat white = saltpepper_noise > _thresW;

    cv::Mat saltpepper_img_mat = img.clone();
    saltpepper_img_mat.setTo(255,white);
    saltpepper_img_mat.setTo(0,black);

    IplImage  saltpepper_img = (IplImage)saltpepper_img_mat;
    return &saltpepper_img;
}


template<class ImageHyper>
IplImage *  denoising(IplImage * _image, IplImage* _noisy, char* _savePath = ""){

    ImageHyper hyper(_noisy);
    //hyper.toFile("noisyHyper.txt");


    IplImage * imdenoise = cvCloneImage(_noisy);
    Hyper::HyperDenoise<ImageHyper >::hyperDenoise(hyper, imdenoise);
    double psnr = Hyper::HyperDenoise<ImageHyper >::compute_PSNR(_image, imdenoise);
    std::cout<<"[Denoise] PSNR = "<<psnr<<std::endl;
    
    
    std::vector<const IplImage *> imgs;
    imgs.push_back(_image);
    imgs.push_back(_noisy);
    imgs.push_back(imdenoise);

    std::vector<std::string> names;
    names.push_back("Original");
    names.push_back("Noisy");
    names.push_back("Denoise");
    Hyper::showImages(imgs, names);

    for(int i = 0; i<imgs.size()-1; i++){
        std::string path = _savePath;
        path.append(names.at(i));
        path.append(".jpg");
        cvSaveImage(path.data(), imgs.at(i));
    }
    // save with the PSNR value
    std::string path = _savePath;
    path.append(names.at(imgs.size()-1));
    path.append("_");
    path.append(boost::lexical_cast<std::string>(psnr).data());
    path.append("_.jpg");
    cvSaveImage(path.data(), imgs.at(imgs.size()-1));
}



int main( int argc, char** argv )
{
    if( argc != 3)
    {
     cout <<" Usage: ./main cleanImagePath noisePercentage" << endl;
     return -1;
    }

    IplImage *  image = cvLoadImage(argv[1], CV_LOAD_IMAGE_GRAYSCALE);

    if(! image->imageData)
    {
        cout <<  "Could not open or find the image : "<<argv[1] << std::endl ;
        return -1;
    }
    int thresWhite  = 255 - 255*0.5*atoi(argv[2]);
    int thresBlack  = 255*0.5*atoi(argv[2]);
    IplImage* noisy = putNoise(image, treshWhite, treshBlack);

    denoising<IANH>(image, noisy);
    //denoising<NLIH>(image, noisy);

    return 0;
}

// @Tramx

