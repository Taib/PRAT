
/*  @Tramx   */

#include <opencv2/core/core.hpp>
#include "opencv2/opencv.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"

#include <boost/lexical_cast.hpp>

#include <iostream>
#include "IANH.h"
#include "NLIH.h"



#include "HyperDenoise.h"
#include "HyperMorpho.h"
#include "ImageNeighborKernel.h"
#include "DistanceKernel.h"
#include "SLIC_Hyper.h"
#include <ctime>

using namespace std;
typedef Hyper::IANH<Hyper::ImageNeighborKernel::NeighborSmall, Hyper::PixelDistanceKernel::AbsDistance1D> IANH;
typedef Hyper::NLIH<Hyper::ImageNeighborKernel::NeighborSmall, Hyper::PixelDistanceKernel::AbsDistance1D> NLIH;


template<class ImageHyper>
void segmentation(IplImage *image){
    //////////////////////// SEGMENTATION //////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

    int kway = 30;
    ImageHyper hyper(image);
    std::cout<<"[Segmentation] card(hyper) = "<<hyper.getSize()<<std::endl;
    hyper.toWeightedFile("weighed_imageHyper.hgr", image);
    //system("/home/tramx/Documents/hmetis-1.5-linux/shmetis ../../build_cpp_prat/weighted_ianh.hgr 40 5");

    /* The Hmetis segmentation file must be accessible to execute the code below! */
    /****************************************
    std::ifstream part;
    part.open("weighed_ianh.hgr.part.30");
    std::vector<Hyper::HyperEdge> blocks(kway);
    std::string aux;
    if( !part.is_open()) {
        std::cout<<"No partition file found"<<std::endl;
        return;
    }
    for(long i = 0; i<hyper.getSize(); i++){
        part >> aux;
        blocks[atoi(aux.data())].add(i);
    }
    part.close();
   IplImage * segment =cvCreateImage(cvSize(image->width,image->height), IPL_DEPTH_8U, 1);
    std::vector<int> mean_blocks;
    for(int j = 0; j<kway; j++){
        mean_blocks.push_back(uint( Hyper::Utils::mean(hyper.neighborsValues( blocks[j])).val[0]));
    }
    std::cout<<"begin"<<std::endl;
    for(long i = 0; i < hyper.getSize(); i++){
        int kpart = -1;
        for(int j = 0; j<kway;j++){
            if(blocks[j].setContains(i)) {
                kpart = j;
                break;
            }
        }
        CvPoint pos = Hyper::Utils::numToCoord(i, image->width);
        //segment.at<uchar>(pos.x, pos.y) = uchar(uint(mean_blocks[kpart] ));
        cvSet2D(segment, pos.x, pos.y, cvScalar(uint(mean_blocks[kpart] )));

    }

    cvNamedWindow( "Original window", CV_WINDOW_NORMAL );
    cvShowImage("Original window", image );
    cvNamedWindow( "segmented window", CV_WINDOW_NORMAL );
    cvShowImage( "segmented window", segment );

    cvWaitKey(0);
    cvDestroyWindow("Original window");
    cvDestroyWindow("segmented window");
    cvSaveImage("segment_irm_30.jpg", segment);
    //////////////////////////////////////////////////////////////////////////********/
}


int main( int argc, char** argv )
{
    if( argc != 2)
    {
     cout <<" Usage: ./main ImageToLoadAndDisplay" << endl;
     return -1;
    }

   IplImage *  image = cvLoadImage(argv[1], CV_LOAD_IMAGE_GRAYSCALE);

   if(! image->imageData)
    {
        cout <<  "Could not open or find the image : "<<argv[1] << std::endl ;
        return -1;
    }
   segmentation(image);
}
